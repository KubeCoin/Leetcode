class Solution {
    public int removeDuplicates(int[] nums) {
        int length = 0;
        if (nums.length == 0){
            return 0;
        }
        for (int i = 1; i < nums.length; i += 1){
            if (nums[length] != nums[i]){
                length += 1;
                nums[length] = nums[i];
            }
        }
        return length + 1;
    }
}
/**
这个题是一个排序好的数组：所以就是由小到大。
然后要剔除重复的元素，不用管别的。返回类型是一个整型，意思是有多少个不一样的。
打个比方 输入 [0,0,1,1,1,2,2,3,3],数组只是变成长度一致的 [0,1,2,3,剩下的随意]就可以了。
但是这个返回的整型标志着长度多少。

分析：
这个方法很巧妙:
先考虑数组如果是空，则直接返回 0；
然后由于返回的整型N 和 我们想要的数组的前N位一样，我们可以用它来当指针。
由于数组已经排序好了，for循环只会依次遇到新的数字，而不会遇到出现过的数字。
所以只要遇到了不等于指针现在所处位置的数字，那就是新的数字。
此时我们就让指针往下移一位，即N++,然后令+1位置的数值等于这个
新出现的数字即可。这样只需要循环一次，就可以获得一次所有的不重复数字。
由于指针最后停的位置在 N - 1, 我们需要返回 N，所以返回 length + 1;
*/
